{"meta":{"title":"DJ1-1 1vU","subtitle":"","description":"","author":"😈Ray","url":"http://hashZzz.github.io","root":"/"},"pages":[{"title":"guestbook","date":"2022-05-08T11:24:51.000Z","updated":"2022-05-08T11:25:08.117Z","comments":true,"path":"guestbook/index.html","permalink":"http://hashzzz.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-05-08T11:21:28.000Z","updated":"2022-05-08T11:23:34.061Z","comments":false,"path":"tags/index.html","permalink":"http://hashzzz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mock-server","slug":"mock-server","date":"2022-06-14T13:22:59.000Z","updated":"2022-06-18T04:11:36.326Z","comments":true,"path":"2022/06/14/mock-server/","link":"","permalink":"http://hashzzz.github.io/2022/06/14/mock-server/","excerpt":"","text":"在CRA中创建一个mock-server的接口服务，目的为了在离线状态下启动，能够调用本地的JSON文件 第一步区分环境变量我们需要将离线环境和正常网络环境区分开来 12345678// 使用了cross-env包区分 科普// npm i cross-env -D// REACT_APP 开头的可以被识别&quot;start&quot;: &quot;cross-env REACT_APP_ENV=DEVELOPMENT react-app-rewired start&quot;&quot;local&quot;: &quot;cross-env REACT_APP_ENV=LOCAL react-app-rewired start&quot; 配置文件使用overrides文件的方法mergeOptions到webpack.config.js里面去执行npm i customize-cra -D在根目录下创建config-overrides.js文件 12345678910//config.overrides.jsconst &#123; overrideDevServer &#125; = require(&#x27;customize-cra&#x27;);const devServerConfig = () =&gt; (config) =&gt; &#123; return config;&#125;module.exports = &#123; devServer: overrideDevServer(devServerConfig()),&#125;; 思路理一理1、根据环境遍历区分是离线模式（调用本地JSON) 在线模式（middleware调用接口）2、离线模式=&gt;调用接口=&gt;读取本地JSON3、在线模式=&gt;调用接口=&gt;获取返回报文写入JSON 12345678910111213const fs = require(&#x27;fs-extra&#x27;);const path = require(&#x27;path&#x27;);const fetch = require(&#x27;node-fetch&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const packageData = require(&#x27;./package.json&#x27;);const &#123; overrideDevServer &#125; = require(&#x27;customize-cra&#x27;);const currHost = &#x27;http://localhost:3000&#x27;;let proxyTarget;if (process.env.REACT_APP_ENV === &#x27;DEVELOPMENT&#x27;) &#123; proxyTarget = packageData.proxy;&#125;","categories":[],"tags":[]},{"title":"vue-array","slug":"vue-array","date":"2022-05-29T12:08:10.000Z","updated":"2022-05-29T12:36:31.895Z","comments":true,"path":"2022/05/29/vue-array/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/vue-array/","excerpt":"","text":"Vue数组是怎么实现响应式的Vue2中 响应式是通过Object.defineProperty(target,key config)方法，在getter和setter中添加依赖和监听来实现响应式的，但是在数组中对下标进行修改无法触发响应式 官网：Vue 不能检测以下数组的变动：当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength Vue2中重写了push,pop,shift,unshift,splice,sort,reverse 使得数组改变时能够触发响应式，把原先Array.prototype进行备份，再进行重写 123456789101112131415161718192021222324252627const methodsNeedChange = [&#x27;push&#x27;,&#x27;pop&#x27;,&#x27;unshift&#x27;,&#x27;shift&#x27;,&#x27;sort&#x27;,&#x27;reverse&#x27;,&#x27;splice&#x27;]methodsNeedChange.forEach(item =&gt; &#123; const original = Array.prototype[item] def(Array,prototype, item, function()&#123; const result = original.apply(this, arguments); const args = [...arguments]; const ob = this.__ob__; let inserted = []; // 判断类型 switch(item) &#123; case &#x27;push: case &#x27;unshift&#x27;: inserted = arguments; break; case &#x27;splice&#x27;: inserted = args.slice(2); break; if(inserted) &#123; ob.observerArray(inserted); &#125; return result; &#125; &#125;, false)&#125;) 通过Vue.$set(Array,index,value)也可以给数组响应式的添加项目 通过splice方法设置数组长度：vm.items.splice(newLength)","categories":[],"tags":[{"name":"Vue原理","slug":"Vue原理","permalink":"http://hashzzz.github.io/tags/Vue%E5%8E%9F%E7%90%86/"}]},{"title":"vue-v3","slug":"vue-v3","date":"2022-05-29T03:26:44.000Z","updated":"2022-05-29T13:33:25.396Z","comments":true,"path":"2022/05/29/vue-v3/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/vue-v3/","excerpt":"","text":"Vue2迁移V3 —上1、$set $delete 响应式API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//V2中 使用Vue.$set来为对象响应式添加值Vue.$set(target,key,value);//V3中 由于使用了new Proxy实现响应式import &#123; ref, reactive, customRef &#125; from &#x27;vue&#x27;;const target = ref(0);target.value ++ ;const state = reactive(&#123; name: &#x27;burning&#x27;&#125;)state.name = &#x27;rotk&#x27;;// 其他的一些api // shallowReactive只保留自身Property 不往下递归添加相应 shallowReactive(target)// toRaw 解除响应式 // markRow 标记对象，标记后不会被添加为响应式对象// unref 判断对象是否ref 是ref返回.value 否则返回对象// toRef 和 toRefs 将reactive中的property转化为ref对象// customRef 这个挺好用的 创建自定义ref并对依赖项进行显示控制接受track和trigger，并返回带有get和set的对象// Vue2 中如果要添加debounce，得用匿名函数包裹const debounceRef = (value, delay) =&gt; &#123; let timer; return customRef((track, trigger) =&gt; &#123; return &#123; get()&#123; track(); return value; &#125;, set(newVal)&#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; value = newVal; trigger(); &#125;, delay); &#125; &#125; &#125;)&#125;// triggerRef(target) 手动触发watchEffect的事件watchEffect(() =&gt; &#123; console.log(&#x27;hello,world&#x27;)&#125;)triggerRef(target); Composition API算是改动比较大的了 123456789101112131415161718192021222324252627282930313233// defineComponent写法export default defineComponent(&#123; setup(props, context)&#123; context.attrs context.slots context.emit // 这个用来暴露方法和属性给外部调用 // 如果没有定义expose 通过ref获取就是setup 对应return // 如果定义了expose 通过ref获取的就是expose的内容 会覆盖return context.expose &#125;&#125;)// export 写法export default &#123; setup()&#123; &#125;&#125;// script写法&lt;script setup lang=&#x27;ts&#x27;&gt; const props = defineProps(&#123;&#125;) const emits = defineEmtis([&#x27;click&#x27;]) const expose = defineExpose(&#123;&#125;) // typescript中接受需要调用withDefaults const props = withDefaults(defineProps&lt;Props&gt;(), &#123; // 这里是props &#125;)&lt;/script&gt; 从生命周期来看 setup在beforeCreated和created之前， Vue3删除了beforeCreate和created，在setup中this也不会指向组件实例 setup函数的第一个参数是props，父组件传给子组件的参数，但是不能使用直接解构取值，否则会丢失响应式，需要通过toRefs defineAsyncComponent官方解释：创建一个只有在需要时才会加载的异步组件。 12345678910111213import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; import(&#x27;./components/AsyncComponent.vue&#x27;))//带配置的const AsyncComp = defineAsyncComponent(&#123; loader: () =&gt; import (&#x27;./components/AsyncComponent.vue&#x27;), loadingComponent: LoadingComponent, errorComponent: ErrorComponent, delay: 200, timeout: 3000&#125;) Provide/Inject父子组件传参，也可以替代prototype，provide和inject设计是非响应式的，当然，如果传递了带响应式的数据时，接收到的也是响应式的 getCurrentInstanceVue3中删除了暴露在prototype上的方法，提供了globalProperties但是Vue3文档中 12345678//getCurrentInstance 只暴露给高阶使用场景，典型的比如在库中。强烈反对在应用的代码中使用 getCurrentInstance。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。// main.tsapp.config.globalProperties.$xxx;const currInstance = getCurrentInstance();currInstance.$xxx();","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]},{"title":"clouse","slug":"clouse","date":"2022-05-29T02:08:20.000Z","updated":"2022-05-29T02:26:00.353Z","comments":true,"path":"2022/05/29/clouse/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/clouse/","excerpt":"","text":"闭包谈到闭包 我理解应该先从js的作用域开始说起，由于JS是词法作用域函数声明的时候相关的上下文环境已经确定而由于作用域的特性（栈内存），函数可以向上访问作用域，但是不能向下访问这个时候通过函数内部嵌套函数将作用域中保存的内容(AO,VO)返回出来 我理解的闭包用一句话概括闭包就是保存了其他函数作用域的函数 使用闭包应当注意，由于闭包保存在堆内存中，避免内存泄漏应当手动清除 工作中常见的闭包使用场景：防抖节流中将setTimeout 定时器返回出来避免清除","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Typescript","slug":"typescript","date":"2022-05-29T02:08:20.000Z","updated":"2023-03-20T13:18:45.730Z","comments":true,"path":"2022/05/29/typescript/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/typescript/","excerpt":"","text":"Typescript一直没有系统的学习TS，边工作边学习，今天抽空整理一下APi 12345678910111213141516171819202122232425262728293031323334353637383940// 基础类型const status: boolean = true;const count: number = 0;const name: string: &#x27;黑色柳丁&#x27;;const uni: undefined = undefined;const nul: null = nullconst any: any = &#x27;&#x27; // any类型 与unknown类型一样const unknown: unknown = ??? // Enum 类型 一般用来创建数值集合 初始值为0，其余成员按顺序自动增长enum List &#123; Apple, Pitch, Watermelon&#125;const apple: List = List.Apple; // 0//如果加上 Apple = 10 const pitch: List = List.Pitch; // 1//如果定义字符串枚举类enum Animal &#123; DOG = &#x27;狗&#x27; CAT = &#x27;猫&#x27;&#125;const dog: Animal = Animal.DOG; // 狗// 如果定义由这些常量组成的数组类型则用以下方式const strs: string[] = [];const animals: Animal[] = [Animal.DOG, Animal.CAT]; // [狗，猫]// never类型 表示那些用不存在的值 刚开始被他折磨的死去活来的 一般用来抛出异常// void 类型 一般用来没有返回值的函数function init(): void &#123; this.mounted();&#125; 123456789101112131415161718192021222324// 对象类型class Animal &#123; type: string; constructor(age: number, type: string) &#123; this.type = type; this.age = age; &#125; cry(): void &#123; console.log(&#x27;5555555&#x27;); &#125;&#125;const animals: Array&lt;Animal&gt; = [];const animals: Animal[] = [];interface Animal &#123; type: string; name: string; age: number;&#125;type name = stringtype Animal = &#123; name: name; age: number &#125; 123456789101112131415161718192021222324// 类型断言const str: string = &#x27;abc&#x27;;const strLength: number = (&lt;string&gt;str).length;const strLength: number = (str as string ).length;// 多种类型let FollowStatus: string | undefined | null ;// 类型合并interface Animal &#123; name: string,&#125;interface Fish &#123; age: number,&#125;let that: Animal &amp; Fish = &#123; name: &#x27;两栖动物&#x27;, age: 1&#125; 高阶用法未完待续","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://hashzzz.github.io/tags/typescript/"}]},{"title":"prototype","slug":"prototype","date":"2022-05-28T13:19:51.000Z","updated":"2022-05-29T02:07:45.343Z","comments":true,"path":"2022/05/28/prototype/","link":"","permalink":"http://hashzzz.github.io/2022/05/28/prototype/","excerpt":"","text":"Prototype 原型和原型链原型和原型链我理解要从New关键字说起我们通过New关键字创造实例 1234// 创造了一个newObject 我们打印这个对象看看const newObj = new Object(); New首先创建了一个对象执行构造函数里面的代码并给对象设置了prototype绑定了this到对象上，设置constructor指向构造函数最后把新对象返回出来 我们来简单模拟一下new 12345678910111213141516function myNew(target) &#123; const newTarget = Object.create(targetFn.prototype); // 获取参数 const args = Array.from(arguments).slice(1); // 绑定this const value = targetFn.apply(newTarget, args); // 判断返回值是不是对象 const targetType = Object.prototype.toString.call(value).slice(8, -1) if([&#x27;Function&#x27;, &#x27;Object&#x27;].includes(targetType)) &#123; return value; &#125; else &#123; return newTarget &#125;&#125; 构造函数通过prototype指向原型对象构造函数创造的实例通过__protot__访问原型对象prototype原型对象通过constructor指向构造函数构造函数通过__proto__访问Object.prototype上的方法Object的prototype隐式指向null而JS中的继承就是以实例的prototype作为父类向下传递的这种链式关系我理解就是原型链","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"vue-router4-addRoute","slug":"vue-router4-addRoute","date":"2022-05-28T05:13:20.000Z","updated":"2022-05-28T13:17:55.399Z","comments":true,"path":"2022/05/28/vue-router4-addRoute/","link":"","permalink":"http://hashzzz.github.io/2022/05/28/vue-router4-addRoute/","excerpt":"","text":"Vue3搭配Vue-Router4 动态添加路由调整 Vue-Router4 删除了addRoutes方法，提供了addRoute方法 1234//添加一条路由记录 如果路由有一个 name，并且已经有一个与之名字相同的路由，它会先删除之前的路由。 addRoute(parentName: string | symbol, route: RouteRecordRaw): () =&gt; void 在 router.beforeEach 中判断权限和信息之后，调用addRoute方法 不同的是需要配置一个条件用来结束循环 搭配以下next写法 123 next(&#123;...to, replace: true &#125;) 1234567891011121314151617181920212223242526// 添加404匹配let flag = false;router.beforeEach((to,from,next) =&gt; &#123; if(!flag) &#123; //异步代码回调中执行以下操作 router.addRoute(&#123; path: &quot;/:catchAll(.*)*&quot;, name: &#x27;404&#x27;, component: () =&gt; import(&#x27;@/component&#x27;) &#125;) dynamicRoutes.forEach(route =&gt; &#123; router.addRoute(route.parent, route) &#125;) // 动态路由添加完成后修改flag，表明已经添加完成 正常调用next方法 flag = true next(&#123; ...to, replace: true &#125;) &#125; else &#123; next() &#125;&#125;)","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]},{"title":"task-context","slug":"task-context","date":"2022-05-22T14:09:31.000Z","updated":"2022-05-28T13:18:08.533Z","comments":true,"path":"2022/05/22/task-context/","link":"","permalink":"http://hashzzz.github.io/2022/05/22/task-context/","excerpt":"","text":"异步任务中存在宏任务和微任务 执行顺序 同步任务=&gt; 异步任务 同步代码执行遇见宏任务 放入宏任务队列遇见微任务 放入微任务队列当执行栈为空时取出微任务执行微任务执行完后取出宏任务执行每个宏任务之后会检查微任务队列，清空微任务再执行宏任务","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"formComponent","slug":"form-component","date":"2022-05-19T13:48:41.000Z","updated":"2022-05-28T13:18:14.831Z","comments":true,"path":"2022/05/19/form-component/","link":"","permalink":"http://hashzzz.github.io/2022/05/19/form-component/","excerpt":"","text":"两种封装Form的方法对比 1234567891011121314151617181920212223242526272829303132333435363738394041// 常用数据源 组件库用的iview-designprops: &#123; formInits: [ &#123; type: &#x27;Input&#x27;, label: &#x27;我是测试label1&#x27;, formKey: &#x27;name&#x27;, value: &#x27;&#x27;, attrs: &#123; placeholder: &#x27;我是测试placeholder&#x27;, size: &#x27;small&#x27; &#125;, listeners: &#123; &#x27;on-change&#x27;: function(ev)&#123; console.log(_this.$refs.formWrapper.$refs.generateForm) &#125; &#125; &#125;, &#123; type: &#x27;Select&#x27;, label: &#x27;我是测试label2-select&#x27;, formKey: &#x27;year&#x27;, value: &#x27;&#x27;, options: [ &#123; label: 2021, value: 2021 &#125;, &#123; label: 2022, value: 2022 &#125; ], attrs: &#123; placeholder: &#x27;请选择!!&#x27;, &#125; &#125;, ] &#125;&#125; 使用template语法 12345678&lt;Form ref=&quot;generateForm&quot; :model=&#x27;formState&#x27; :rules=&#x27;rules&#x27;&gt; &lt;FormItem :label=&#x27;item.label&#x27; :prop=&quot;item.formKey&quot; v-for=&quot;item in formInits&quot; :key=&#x27;item.formKey&#x27;&gt; &lt;Input v-if=&quot;item.type === &#x27;Input&#x27;&quot; type=&quot;text&quot; v-bind=&#x27;item.attrs&#x27; v-on=&quot;item.listeners&quot;&gt;&lt;/Input&gt; &lt;Select v-else-if=&quot;item.type === &#x27;Select&#x27;&quot; v-bind=&#x27;item.attrs&#x27; v-on=&quot;item.listeners&quot;&gt; &lt;Option v-for=&#x27;opt in item.options&#x27; :key=&#x27;opt.value&#x27; :value=&#x27;opt.value&#x27;&gt;&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt;&lt;/Form&gt; 使用render语法 123456789101112131415161718192021222324252627282930313233343536373839// 这里更加推荐安装JSX-loader 就没有这么痛苦render(createElement)&#123; const returnFormSlot = (&#123; type, options &#125;) =&gt; &#123; switch(type) &#123; case &#x27;Input&#x27;: break; case &#x27;Select&#x27;: return options &amp;&amp; options.map(option =&gt; &#123; return createElement(&#x27;Option&#x27;, &#123; props: &#123; key: option.value, value: option.value, &#125;, &#125;, option.label) &#125;) break; &#125; &#125; return createElement(&#x27;Form&#x27;, &#123; ref: &#x27;generateForm&#x27;, props: &#123; model: this.formState, rules: this.rules &#125; &#125;, this.formInits.map(item =&gt; &#123; return createElement(&#x27;FormItem&#x27;, &#123; props: &#123; label: item.label, prop: item.formKey, &#125; &#125;,[createElement(item.type, &#123; props: item.attrs, on: item.listeners &#125;, returnFormSlot(item) )]) &#125;) )&#125;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]},{"title":"canvas-water-print","slug":"canvas-water-print","date":"2022-05-10T13:37:10.000Z","updated":"2022-05-28T13:18:23.006Z","comments":true,"path":"2022/05/10/canvas-water-print/","link":"","permalink":"http://hashzzz.github.io/2022/05/10/canvas-water-print/","excerpt":"","text":"Canvas生产base64的水印 123456789101112131415161718192021function setWaterPrint(str, elem, fs, color)&#123; var canvas = document.createElement(&#x27;canvas&#x27;); if(elem &amp;&amp; elem.nodeType) &#123; elem.appendChild(canvas); &#125; else &#123; return console.error(&quot;Invalid Target&quot;) &#125; canvas.width = 250; canvas.height = 200; canvas.style.display = &#x27;none&#x27;; var ctx = canvas.getContext(&#x27;2d&#x27;); ctx.rotate( (Math.PI * - 10) / 180 ); ctx.font = fs || &#x27;16px Microsoft YaHei&#x27;; ctx.fillStyle = color || &#x27;rgba(200,200,200, 0.3)&#x27;; ctx.textAlign = &#x27;center&#x27; ctx.textBaseline = &#x27;Middle&#x27;; ctx.fillText(str, canvas.width / 10, canvas.height / 2); elem.style.backgroundImage = &quot;url(&quot; + can.toDataURL(&quot;image/png&quot;) + &quot;)&quot;&#125;// 绑定到Dom上","categories":[],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://hashzzz.github.io/tags/Canvas/"}]}],"categories":[],"tags":[{"name":"Vue原理","slug":"Vue原理","permalink":"http://hashzzz.github.io/tags/Vue%E5%8E%9F%E7%90%86/"},{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"},{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"typescript","slug":"typescript","permalink":"http://hashzzz.github.io/tags/typescript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hashzzz.github.io/tags/Canvas/"}]}