{"meta":{"title":"DJ1-1 1vU","subtitle":"","description":"","author":"😈Ray","url":"http://hashZzz.github.io","root":"/"},"pages":[{"title":"guestbook","date":"2022-05-08T11:24:51.000Z","updated":"2022-05-08T11:25:08.117Z","comments":true,"path":"guestbook/index.html","permalink":"http://hashzzz.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-05-08T11:21:28.000Z","updated":"2022-05-08T11:23:34.061Z","comments":false,"path":"tags/index.html","permalink":"http://hashzzz.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Map、WeakMap、Set、WeakSet","slug":"MapVsWeakMap","date":"2024-05-29T13:37:10.000Z","updated":"2024-05-29T12:55:39.595Z","comments":true,"path":"2024/05/29/MapVsWeakMap/","link":"","permalink":"http://hashzzz.github.io/2024/05/29/MapVsWeakMap/","excerpt":"","text":"ES6中新增了Map、Set、WeakMap、WeakSet几个数据结构，他们各自都有不同的特点和使用场景 Map是一种键值对结构的数据集合，表现为Key-Value的形式， 这里的Key可以是任意值但是不能重复 下面是map的设置、取值、查询、删除、清空几个操作，遍历方法会放到Set之后一并介绍 12345678let map = new Map();map.set(&#x27;name&#x27;, &#x27;Alice&#x27;);const name = map.get(&#x27;name&#x27;);map.has(&#x27;name&#x27;)map.delete(&#x27;name&#x27;);map.clear(); Set呢是一种存储唯一值的结构，适用于存储不重复元素的场景，无序、不重复、值可以是任意类型 123456789101112131415let set = new Set();set.add(1);set.add(2);set.add(2); // 尝试添加重复值console.log(set.has(1)); // 输出: trueconsole.log(set.size); // 输出: 2set.delete(2);console.log(set.size); // 输出: 1set.clear();console.log(set.size); // 输出: 0 一般会用来存一些枚举值 坐标点位较多 WeakMap与Map WeakMap 是一种弱引用的键值对类型，键只能是对象，且如果对象没有被引用，那么就会被垃圾回收处理掉，WeakMap也不能枚举，无法使用forEach，keys，values，entries等方法，一般用Dom作为键比较场景，当Dom移除之后会自动清理 WeakSet同理","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"canvas-water-print","slug":"canvas-water-print","date":"2024-05-29T13:37:10.000Z","updated":"2024-05-29T12:29:18.764Z","comments":true,"path":"2024/05/29/canvas-water-print/","link":"","permalink":"http://hashzzz.github.io/2024/05/29/canvas-water-print/","excerpt":"","text":"Canvas生产base64的水印 123456789101112131415161718192021function setWaterPrint(str, elem, fs, color)&#123; var canvas = document.createElement(&#x27;canvas&#x27;); if(elem &amp;&amp; elem.nodeType) &#123; elem.appendChild(canvas); &#125; else &#123; return console.error(&quot;Invalid Target&quot;) &#125; canvas.width = 250; canvas.height = 200; canvas.style.display = &#x27;none&#x27;; var ctx = canvas.getContext(&#x27;2d&#x27;); ctx.rotate( (Math.PI * - 10) / 180 ); ctx.font = fs || &#x27;16px Microsoft YaHei&#x27;; ctx.fillStyle = color || &#x27;rgba(200,200,200, 0.3)&#x27;; ctx.textAlign = &#x27;center&#x27; ctx.textBaseline = &#x27;Middle&#x27;; ctx.fillText(str, canvas.width / 10, canvas.height / 2); elem.style.backgroundImage = &quot;url(&quot; + can.toDataURL(&quot;image/png&quot;) + &quot;)&quot;&#125; 功能增强，防止用户删除Element元素 使用Class封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class WaterMark &#123; constructor(el, content) &#123; this.el = el; this.content = content; this.observer = null; this.config = &#123; attributes: true, childList: true, subtree: true &#125;; this.init(); &#125; init() &#123; this.createContext(this.el); &#125; createContext(elem) &#123; const &#123; offsetWidth, offsetHeight &#125; = elem; const canvas = document.createElement(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); canvas.width = offsetWidth; canvas.height = offsetHeight; canvas.style.position = &quot;absolute&quot;; canvas.style.pointerEvents = &quot;none&quot;; canvas.style.top = &quot;0px&quot;; canvas.style.left = &quot;0px&quot;; canvas.style.zIndex = &quot;99&quot;; ctx.font = &quot;24px serif&quot;; ctx.rotate((-20 * Math.PI) / 180); ctx.fillStyle = &quot;rgba(180, 180, 180, 0.6)&quot;; ctx.textAlign = &quot;left&quot;; ctx.textBaseline = &quot;middle&quot;; // 循环在canvas中渲染 for (let i = 0; i &lt; canvas.width / 100; i++) &#123; for (let j = 0; j &lt; canvas.height / 50; j++) &#123; ctx.fillText(this.content, i * 200, j * 100 + 20); &#125; &#125; elem.appendChild(canvas); this.createObserver(elem); // 添加监听 &#125; createObserver(elem) &#123; if (this.observer) this.observer.disconnect(); this.observer = new MutationObserver((changeList, watcher) =&gt; &#123; Array.from(changeList).forEach((record) =&gt; &#123; const &#123; removedNodes &#125; = record; const removeNodeNames = Array.from(removedNodes).map( (node) =&gt; node.nodeName ); if (removeNodeNames.includes(&quot;CANVAS&quot;)) &#123; window.requestIdleCallback(() =&gt; this.createContext(elem), &#123; timeout: 300, &#125;); &#125; &#125;); &#125;); this.observer.observe(elem, this.config); &#125;&#125;const elem = document.getElementById(&quot;content&quot;);const waterMark = new WaterMark(elem, &quot;hello, world&quot;);","categories":[],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://hashzzz.github.io/tags/Canvas/"}]},{"title":"封装一个FetchClient","slug":"Fetch","date":"2024-05-29T13:37:10.000Z","updated":"2024-06-08T06:05:22.596Z","comments":true,"path":"2024/05/29/Fetch/","link":"","permalink":"http://hashzzz.github.io/2024/05/29/Fetch/","excerpt":"","text":"Fetch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122export interface IRequestData extends RequestInit &#123; method: &#x27;GET&#x27; | &#x27;POST&#x27; | &#x27;PUT&#x27; | &quot;DELETE&quot; | &#x27;OPTIONS&#x27; headers?: Record&lt;string, string&gt; body?: string, timeout?: number&#125;// 请求拦截器返回的是一个Promise 新的配置type RequestInterceptor = (url: string, options: IRequestData) =&gt; Promise&lt;[string, IRequestData]&gt; | [string, IRequestData];// 响应返回的是一个泛型type ResponseInterceptor&lt;T&gt; = (response: T, options: IRequestData) =&gt; Promise&lt;T&gt; | T;export default class HttpClient &#123; private defaultTimeout: number; private requestInterceptors: RequestInterceptor[]; private responseInterceptors: ResponseInterceptor&lt;any&gt;[]; constructor(defaultTimeout: number = 10000) &#123; this.defaultTimeout = defaultTimeout; this.requestInterceptors = []; this.responseInterceptors = []; &#125; // 添加请求拦截器 public addRequestInterceptor(interceptor: RequestInterceptor): void &#123; this.requestInterceptors.push(interceptor); &#125; // 添加响应拦截器 public addResponseInterceptor&lt;T&gt;(interceptor: ResponseInterceptor&lt;T&gt;): void &#123; this.responseInterceptors.push(interceptor); &#125; private async applyRequestInterceptors(url: string, options: IRequestData): Promise&lt;[string, IRequestData]&gt; &#123; let result: [string, IRequestData] = [url, options]; for (const interceptor of this.requestInterceptors) &#123; result = await interceptor(...result); &#125; return result; &#125; private async applyResponseInterceptors&lt;T&gt;(response: T, options: IRequestData): Promise&lt;T&gt; &#123; let result = response; for (const interceptor of this.responseInterceptors) &#123; result = await interceptor(result, options); &#125; return result; &#125; // fetch 后面的&lt;T&gt;表示接受一个&lt;T&gt;类型 后面的Promise&lt;T&gt;是一个返回类型 public async fetch&lt;T&gt;(url: string, options: IRequestData): Promise&lt;T&gt; &#123; const &#123; timeout = this.defaultTimeout, ...fetchOptions &#125; = options; const [interceptedUrl, interceptedOptions] = await this.applyRequestInterceptors(url, &#123; timeout, ...fetchOptions &#125;); return new Promise&lt;T&gt;((resolve, reject) =&gt; &#123; const controller = new AbortController(); const signal = controller.signal; interceptedOptions.signal = signal; const timer = setTimeout(() =&gt; &#123; controller.abort(); reject(new Error(&#x27;请求超时&#x27;)); &#125;, timeout); fetch(interceptedUrl, interceptedOptions) .then(async response =&gt; &#123; clearTimeout(timer); if (!response.ok) &#123; const errorText = await response.text(); reject(new Error(errorText || &#x27;请求失败&#x27;)); &#125; else &#123; const jsonResponse = await response.json(); const interceptedResponse = await this.applyResponseInterceptors(jsonResponse, interceptedOptions); resolve(interceptedResponse as T); &#125; &#125;) .catch(error =&gt; &#123; if (error.name === &#x27;AbortError&#x27;) &#123; reject(new Error(&#x27;请求被中止&#x27;)); &#125; else &#123; reject(error); &#125; &#125;); &#125;); &#125; public cancel(controller: AbortController): void &#123; controller.abort(); &#125; // 创建一个新的 AbortController 实例的方法 public createAbortController(): AbortController &#123; return new AbortController(); &#125;&#125;// 代码使用import HttpClient, &#123; IRequestData &#125; from &quot;./fetch&quot;;import &#123; IApiResponse &#125; from &quot;@/types&quot;;export const httpClient = new HttpClient();export const abortControl = httpClient.createAbortController();export const get = (url: string, params?: Record&lt;string, number | string&gt;, options: IRequestData = &#123; method: &#x27;GET&#x27; &#125;): Promise&lt;IApiResponse&gt; =&gt; &#123; let request_url = url; if (params) &#123; request_url += &#x27;?&#x27; Object.entries(params).forEach(([key, value]) =&gt; &#123; request_url += `$&#123;key&#125;=$&#123;value&#125;`; &#125;) &#125; return httpClient.fetch(request_url, options);&#125;;export const post = (url: string, options: IRequestData) =&gt; &#123; return httpClient.fetch(url, options);&#125;;","categories":[],"tags":[{"name":"Fetch","slug":"Fetch","permalink":"http://hashzzz.github.io/tags/Fetch/"}]},{"title":"css面试题","slug":"css","date":"2023-05-11T13:48:41.000Z","updated":"2023-05-11T12:14:38.313Z","comments":true,"path":"2023/05/11/css/","link":"","permalink":"http://hashzzz.github.io/2023/05/11/css/","excerpt":"","text":"flexflex-direction决定主轴的的排列方向 row/column -reverse row(默认) column垂直方向的排列flex-wrapnowrap wrap wrap-reverse 换行flex-flowwrap和direction的合并 row 和 nowrap是默认值justify-content主轴方向的排列对齐方式align-items交叉轴上的对齐方向项目的属性order 排序属性 越小越靠前flex-grow 放大比例flex-shrink缩小比例align-self 自身的排列方式","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"JS面试题","slug":"js-better","date":"2023-05-08T13:48:41.000Z","updated":"2023-05-10T13:12:25.403Z","comments":true,"path":"2023/05/08/js-better/","link":"","permalink":"http://hashzzz.github.io/2023/05/08/js-better/","excerpt":"","text":"JS面试题1、JS的数据类型，值是如何存储的 基础类型： string number boolean Symbol复杂类型值： Object Array null undefined 基础类型值存储在栈中，引用类型值存在堆中，指针存储在栈中，指针指向堆中的地址 2、null和undefined的区别undefined偏向于未定义，null表示是空对象当变量声明没定义的时候就是undefined，typeof null 输出object,而typeof undefined为undefined 3、valueOf和toString()，这俩方法都是javascript内置的取值方法 toString返回的是字符串，而valueOf返回的是原始值，null和undefined都没有这两个方法 {} valueOf 结果为 {} 原始值[] valueOf 结果为 [] 原始值{} toString 结果为 ‘[object Object]’[] toString 结果为 ‘’; 4、javascript的作用域和作用域链 作用域是定义变量的区域，也是词法作用域，在这个区域内决定了变量和其他资源的可见性在函数内部可以向父级访问变量，而函数外部不能访问函数内部的值由这种关系组成的链条就叫作用域链 5、什么情况会造成内存泄漏？全局变量、闭包、遗忘的定时器 6、ES6新增了哪些东西 Promise、箭头函数、类、解构赋值、let、const声明、Symbol、Map、Set、模板字符串、模块化、Proxy、函数默认参数、点运算符","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue面试题","slug":"vue-better","date":"2023-05-08T13:48:41.000Z","updated":"2023-05-08T14:04:50.314Z","comments":true,"path":"2023/05/08/vue-better/","link":"","permalink":"http://hashzzz.github.io/2023/05/08/vue-better/","excerpt":"","text":"Vue面试题1、v-if和v-show的频繁切换，利用其缓存特性，首屏使用v-if2、列表标记key3、数据响应式处理，如果不需要响应式处理的数据增加Object.freeze4、路由异步加载5、UI组件库按需引入6、抽离公共代码，使用mixin Vue组件通信的方法 1、通过props2、用过$bus $emit触发自定义事件3、使用$ref4、使用$parent和$children5、使用attrs和$listeners6、Provider和Inject7、Vuex8、V-model和$emit update Vue中$nextTick怎么用的，实现原理是什么？ $nextTick用于Dom更新更新结束后执行的回调，修改数据后立刻调用这个方法，可以获取更新后的Dom，在created中访问DOM可以使用这个方法 当数据发生变化时,Vue将回调放入异步更新队列，等队列中所有的数据变化完后再统一更新，不然每次更新数据都会触发更新具体代码 12345678910111213141516171819202122232425262728293031const callbacks = []let pending = falseexport function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve // 用 callbacks 数组存储经过包装的 cb 函数 callbacks.push(() =&gt; &#123; if (cb) &#123; // 用 try catch 包装回调函数，便于错误捕获 try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true // 执行 timerFunc，在浏览器的任务队列中（首选微任务队列）放入 flushCallbacks 函数 timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 虚拟DOM是什么？ 虚拟Dom实际上是把Dom节点的attributes、Event、Content等等以对象的形式储存，通过Compiler将对象转化为HTMl结构的 为什么组件的data属性是一个函数，而不是对象 我们通过Vue.component创建多个组件的时候，如果data是一个属性，那么就会共用这个data，修改A也会影响B，当使用function return data的时候，就隔绝了相互之间的影响 Vue的初始化过程你有了解过吗？做过哪些事情 第一步是接收用户自定义的一些配置，和Vue自己定义的一些策略进行合并第二步是初始化生命周期、事件、data、props、computed、watcher、调用周期钩子第三步：使用$mount挂载","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"vue-v3","slug":"vue3-proxy","date":"2023-05-06T03:26:44.000Z","updated":"2023-05-08T12:53:02.892Z","comments":true,"path":"2023/05/06/vue3-proxy/","link":"","permalink":"http://hashzzz.github.io/2023/05/06/vue3-proxy/","excerpt":"","text":"Vue2与Vue3响应式原理Vue2的响应式核心是使用Object.defineProperty劫持对象，然后进行深度遍历，给每个属性设置setter和getter，Vue3使用proxy对象重写响应式，通过Reflect对源对象的属性进行操作 1234567891011121314151617181920function defineReactive(obj, key, val) &#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; const value = val; // 触发getter的时候收集依赖 if (Dep.target) &#123; dep.depend(); &#125; return value; &#125;, set(newVal) &#123; val = newVal; // 调用setter的时候调用dep的notify通知依赖更新 dep.notify(); &#125;, &#125;);&#125; 1234567891011new Proxy(data, &#123; get (target, prop) &#123; return Reflect.get(target, prop); &#125;, set(target, prop, value) &#123; return Reflect.set(target, prop, value); &#125; deleteProperty(target, prop) &#123; return Reflect.deleteProperty(target, prop); &#125;&#125;)","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]},{"title":"mock-server","slug":"mock-server","date":"2022-06-14T13:22:59.000Z","updated":"2022-06-18T04:11:36.326Z","comments":true,"path":"2022/06/14/mock-server/","link":"","permalink":"http://hashzzz.github.io/2022/06/14/mock-server/","excerpt":"","text":"在CRA中创建一个mock-server的接口服务，目的为了在离线状态下启动，能够调用本地的JSON文件 第一步区分环境变量我们需要将离线环境和正常网络环境区分开来 12345678// 使用了cross-env包区分 科普// npm i cross-env -D// REACT_APP 开头的可以被识别&quot;start&quot;: &quot;cross-env REACT_APP_ENV=DEVELOPMENT react-app-rewired start&quot;&quot;local&quot;: &quot;cross-env REACT_APP_ENV=LOCAL react-app-rewired start&quot; 配置文件使用overrides文件的方法mergeOptions到webpack.config.js里面去执行npm i customize-cra -D在根目录下创建config-overrides.js文件 12345678910//config.overrides.jsconst &#123; overrideDevServer &#125; = require(&#x27;customize-cra&#x27;);const devServerConfig = () =&gt; (config) =&gt; &#123; return config;&#125;module.exports = &#123; devServer: overrideDevServer(devServerConfig()),&#125;; 思路理一理1、根据环境遍历区分是离线模式（调用本地JSON) 在线模式（middleware调用接口）2、离线模式=&gt;调用接口=&gt;读取本地JSON3、在线模式=&gt;调用接口=&gt;获取返回报文写入JSON 12345678910111213const fs = require(&#x27;fs-extra&#x27;);const path = require(&#x27;path&#x27;);const fetch = require(&#x27;node-fetch&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const packageData = require(&#x27;./package.json&#x27;);const &#123; overrideDevServer &#125; = require(&#x27;customize-cra&#x27;);const currHost = &#x27;http://localhost:3000&#x27;;let proxyTarget;if (process.env.REACT_APP_ENV === &#x27;DEVELOPMENT&#x27;) &#123; proxyTarget = packageData.proxy;&#125;","categories":[],"tags":[]},{"title":"vue-array","slug":"vue-array","date":"2022-05-29T12:08:10.000Z","updated":"2022-05-29T12:36:31.895Z","comments":true,"path":"2022/05/29/vue-array/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/vue-array/","excerpt":"","text":"Vue数组是怎么实现响应式的Vue2中 响应式是通过Object.defineProperty(target,key config)方法，在getter和setter中添加依赖和监听来实现响应式的，但是在数组中对下标进行修改无法触发响应式 官网：Vue 不能检测以下数组的变动：当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue当你修改数组的长度时，例如：vm.items.length = newLength Vue2中重写了push,pop,shift,unshift,splice,sort,reverse 使得数组改变时能够触发响应式，把原先Array.prototype进行备份，再进行重写 123456789101112131415161718192021222324252627const methodsNeedChange = [&#x27;push&#x27;,&#x27;pop&#x27;,&#x27;unshift&#x27;,&#x27;shift&#x27;,&#x27;sort&#x27;,&#x27;reverse&#x27;,&#x27;splice&#x27;]methodsNeedChange.forEach(item =&gt; &#123; const original = Array.prototype[item] def(Array,prototype, item, function()&#123; const result = original.apply(this, arguments); const args = [...arguments]; const ob = this.__ob__; let inserted = []; // 判断类型 switch(item) &#123; case &#x27;push: case &#x27;unshift&#x27;: inserted = arguments; break; case &#x27;splice&#x27;: inserted = args.slice(2); break; if(inserted) &#123; ob.observerArray(inserted); &#125; return result; &#125; &#125;, false)&#125;) 通过Vue.$set(Array,index,value)也可以给数组响应式的添加项目 通过splice方法设置数组长度：vm.items.splice(newLength)","categories":[],"tags":[{"name":"Vue原理","slug":"Vue原理","permalink":"http://hashzzz.github.io/tags/Vue%E5%8E%9F%E7%90%86/"}]},{"title":"vue-v3","slug":"vue-v3","date":"2022-05-29T03:26:44.000Z","updated":"2023-05-08T13:02:10.967Z","comments":true,"path":"2022/05/29/vue-v3/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/vue-v3/","excerpt":"","text":"Vue2迁移V3 —上1、$set $delete 响应式API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//V2中 使用Vue.$set来为对象响应式添加值Vue.$set(target,key,value);//V3中 由于使用了new Proxy实现响应式import &#123; ref, reactive, customRef &#125; from &#x27;vue&#x27;;const target = ref(0);target.value ++ ;const state = reactive(&#123; name: &#x27;burning&#x27;&#125;)state.name = &#x27;rotk&#x27;;// 其他的一些api // shallowReactive只保留自身Property 不往下递归添加相应 shallowReactive(target)// toRaw 解除响应式 // markRow 标记对象，标记后不会被添加为响应式对象// unref 判断对象是否ref 是ref返回.value 否则返回对象// toRef 和 toRefs 将reactive中的property转化为ref对象// customRef 这个挺好用的 创建自定义ref并对依赖项进行显示控制接受track和trigger，并返回带有get和set的对象// Vue2 中如果要添加debounce，得用匿名函数包裹const debounceRef = (value, delay) =&gt; &#123; let timer; return customRef((track, trigger) =&gt; &#123; return &#123; get()&#123; track(); return value; &#125;, set(newVal)&#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; value = newVal; trigger(); &#125;, delay); &#125; &#125; &#125;)&#125;// triggerRef(target) 手动触发watchEffect的事件watchEffect(() =&gt; &#123; console.log(&#x27;hello,world&#x27;)&#125;)triggerRef(target); Composition API算是改动比较大的了 123456789101112131415161718192021222324252627282930313233// defineComponent写法export default defineComponent(&#123; setup(props, context)&#123; context.attrs context.slots context.emit // 这个用来暴露方法和属性给外部调用 // 如果没有定义expose 通过ref获取就是setup 对应return // 如果定义了expose 通过ref获取的就是expose的内容 会覆盖return context.expose &#125;&#125;)// export 写法export default &#123; setup()&#123; &#125;&#125;// script写法&lt;script setup lang=&#x27;ts&#x27;&gt; const props = defineProps(&#123;&#125;) const emits = defineEmtis([&#x27;click&#x27;]) const expose = defineExpose(&#123;&#125;) // typescript中接受需要调用withDefaults const props = withDefaults(defineProps&lt;Props&gt;(), &#123; // 这里是props &#125;)&lt;/script&gt; 从生命周期来看 setup在beforeCreated和created之前， Vue3删除了beforeCreate和created，在setup中this也不会指向组件实例 setup函数的第一个参数是props，父组件传给子组件的参数，但是不能使用直接解构取值，否则会丢失响应式，需要通过toRefs defineAsyncComponent官方解释：创建一个只有在需要时才会加载的异步组件。 12345678910111213import &#123; defineAsyncComponent &#125; from &#x27;vue&#x27;const AsyncComp = defineAsyncComponent(() =&gt; import(&#x27;./components/AsyncComponent.vue&#x27;))//带配置的const AsyncComp = defineAsyncComponent(&#123; loader: () =&gt; import (&#x27;./components/AsyncComponent.vue&#x27;), loadingComponent: LoadingComponent, errorComponent: ErrorComponent, delay: 200, timeout: 3000&#125;) Provide/Inject父子组件传参，也可以替代prototype，provide和inject设计是非响应式的，当然，如果传递了带响应式的数据时，接收到的也是响应式的 getCurrentInstanceVue3中删除了暴露在prototype上的方法，提供了globalProperties但是Vue3文档中 12345678//getCurrentInstance 只暴露给高阶使用场景，典型的比如在库中。强烈反对在应用的代码中使用 getCurrentInstance。请不要把它当作在组合式 API 中获取 this 的替代方案来使用。// main.tsapp.config.globalProperties.$xxx;const currInstance = getCurrentInstance();currInstance.$xxx(); CompositionAPI新增compositionAPI，代码逻辑更加清晰 1234567&lt;script setup&gt;import &#123; ref, reactive &#125; from &#x27;vue&#x27;;const count = ref(0);const state = reactive(&#123; name: &#x27;Jack&#x27; &#125;);&lt;/script&gt;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]},{"title":"clouse","slug":"clouse","date":"2022-05-29T02:08:20.000Z","updated":"2022-05-29T02:26:00.353Z","comments":true,"path":"2022/05/29/clouse/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/clouse/","excerpt":"","text":"闭包谈到闭包 我理解应该先从js的作用域开始说起，由于JS是词法作用域函数声明的时候相关的上下文环境已经确定而由于作用域的特性（栈内存），函数可以向上访问作用域，但是不能向下访问这个时候通过函数内部嵌套函数将作用域中保存的内容(AO,VO)返回出来 我理解的闭包用一句话概括闭包就是保存了其他函数作用域的函数 使用闭包应当注意，由于闭包保存在堆内存中，避免内存泄漏应当手动清除 工作中常见的闭包使用场景：防抖节流中将setTimeout 定时器返回出来避免清除","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Typescript","slug":"typescript","date":"2022-05-29T02:08:20.000Z","updated":"2023-03-20T13:18:45.730Z","comments":true,"path":"2022/05/29/typescript/","link":"","permalink":"http://hashzzz.github.io/2022/05/29/typescript/","excerpt":"","text":"Typescript一直没有系统的学习TS，边工作边学习，今天抽空整理一下APi 12345678910111213141516171819202122232425262728293031323334353637383940// 基础类型const status: boolean = true;const count: number = 0;const name: string: &#x27;黑色柳丁&#x27;;const uni: undefined = undefined;const nul: null = nullconst any: any = &#x27;&#x27; // any类型 与unknown类型一样const unknown: unknown = ??? // Enum 类型 一般用来创建数值集合 初始值为0，其余成员按顺序自动增长enum List &#123; Apple, Pitch, Watermelon&#125;const apple: List = List.Apple; // 0//如果加上 Apple = 10 const pitch: List = List.Pitch; // 1//如果定义字符串枚举类enum Animal &#123; DOG = &#x27;狗&#x27; CAT = &#x27;猫&#x27;&#125;const dog: Animal = Animal.DOG; // 狗// 如果定义由这些常量组成的数组类型则用以下方式const strs: string[] = [];const animals: Animal[] = [Animal.DOG, Animal.CAT]; // [狗，猫]// never类型 表示那些用不存在的值 刚开始被他折磨的死去活来的 一般用来抛出异常// void 类型 一般用来没有返回值的函数function init(): void &#123; this.mounted();&#125; 123456789101112131415161718192021222324// 对象类型class Animal &#123; type: string; constructor(age: number, type: string) &#123; this.type = type; this.age = age; &#125; cry(): void &#123; console.log(&#x27;5555555&#x27;); &#125;&#125;const animals: Array&lt;Animal&gt; = [];const animals: Animal[] = [];interface Animal &#123; type: string; name: string; age: number;&#125;type name = stringtype Animal = &#123; name: name; age: number &#125; 123456789101112131415161718192021222324// 类型断言const str: string = &#x27;abc&#x27;;const strLength: number = (&lt;string&gt;str).length;const strLength: number = (str as string ).length;// 多种类型let FollowStatus: string | undefined | null ;// 类型合并interface Animal &#123; name: string,&#125;interface Fish &#123; age: number,&#125;let that: Animal &amp; Fish = &#123; name: &#x27;两栖动物&#x27;, age: 1&#125; 高阶用法未完待续","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://hashzzz.github.io/tags/typescript/"}]},{"title":"prototype","slug":"prototype","date":"2022-05-28T13:19:51.000Z","updated":"2022-05-29T02:07:45.343Z","comments":true,"path":"2022/05/28/prototype/","link":"","permalink":"http://hashzzz.github.io/2022/05/28/prototype/","excerpt":"","text":"Prototype 原型和原型链原型和原型链我理解要从New关键字说起我们通过New关键字创造实例 1234// 创造了一个newObject 我们打印这个对象看看const newObj = new Object(); New首先创建了一个对象执行构造函数里面的代码并给对象设置了prototype绑定了this到对象上，设置constructor指向构造函数最后把新对象返回出来 我们来简单模拟一下new 12345678910111213141516function myNew(target) &#123; const newTarget = Object.create(targetFn.prototype); // 获取参数 const args = Array.from(arguments).slice(1); // 绑定this const value = targetFn.apply(newTarget, args); // 判断返回值是不是对象 const targetType = Object.prototype.toString.call(value).slice(8, -1) if([&#x27;Function&#x27;, &#x27;Object&#x27;].includes(targetType)) &#123; return value; &#125; else &#123; return newTarget &#125;&#125; 构造函数通过prototype指向原型对象构造函数创造的实例通过__protot__访问原型对象prototype原型对象通过constructor指向构造函数构造函数通过__proto__访问Object.prototype上的方法Object的prototype隐式指向null而JS中的继承就是以实例的prototype作为父类向下传递的这种链式关系我理解就是原型链","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"vue-router4-addRoute","slug":"vue-router4-addRoute","date":"2022-05-28T05:13:20.000Z","updated":"2022-05-28T13:17:55.399Z","comments":true,"path":"2022/05/28/vue-router4-addRoute/","link":"","permalink":"http://hashzzz.github.io/2022/05/28/vue-router4-addRoute/","excerpt":"","text":"Vue3搭配Vue-Router4 动态添加路由调整 Vue-Router4 删除了addRoutes方法，提供了addRoute方法 1234//添加一条路由记录 如果路由有一个 name，并且已经有一个与之名字相同的路由，它会先删除之前的路由。 addRoute(parentName: string | symbol, route: RouteRecordRaw): () =&gt; void 在 router.beforeEach 中判断权限和信息之后，调用addRoute方法 不同的是需要配置一个条件用来结束循环 搭配以下next写法 123 next(&#123;...to, replace: true &#125;) 1234567891011121314151617181920212223242526// 添加404匹配let flag = false;router.beforeEach((to,from,next) =&gt; &#123; if(!flag) &#123; //异步代码回调中执行以下操作 router.addRoute(&#123; path: &quot;/:catchAll(.*)*&quot;, name: &#x27;404&#x27;, component: () =&gt; import(&#x27;@/component&#x27;) &#125;) dynamicRoutes.forEach(route =&gt; &#123; router.addRoute(route.parent, route) &#125;) // 动态路由添加完成后修改flag，表明已经添加完成 正常调用next方法 flag = true next(&#123; ...to, replace: true &#125;) &#125; else &#123; next() &#125;&#125;)","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]},{"title":"task-context","slug":"task-context","date":"2022-05-22T14:09:31.000Z","updated":"2023-03-23T13:48:05.354Z","comments":true,"path":"2022/05/22/task-context/","link":"","permalink":"http://hashzzz.github.io/2022/05/22/task-context/","excerpt":"","text":"异步任务中存在宏任务和微任务 执行顺序 同步任务=&gt; 异步任务 同步代码执行遇见宏任务 放入宏任务队列遇见微任务 放入微任务队列当执行栈为空时取出微任务执行微任务执行完后取出宏任务执行每个宏任务之后会检查微任务队列，清空微任务再执行宏任务","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"formComponent","slug":"form-component","date":"2022-05-19T13:48:41.000Z","updated":"2022-05-28T13:18:14.831Z","comments":true,"path":"2022/05/19/form-component/","link":"","permalink":"http://hashzzz.github.io/2022/05/19/form-component/","excerpt":"","text":"两种封装Form的方法对比 1234567891011121314151617181920212223242526272829303132333435363738394041// 常用数据源 组件库用的iview-designprops: &#123; formInits: [ &#123; type: &#x27;Input&#x27;, label: &#x27;我是测试label1&#x27;, formKey: &#x27;name&#x27;, value: &#x27;&#x27;, attrs: &#123; placeholder: &#x27;我是测试placeholder&#x27;, size: &#x27;small&#x27; &#125;, listeners: &#123; &#x27;on-change&#x27;: function(ev)&#123; console.log(_this.$refs.formWrapper.$refs.generateForm) &#125; &#125; &#125;, &#123; type: &#x27;Select&#x27;, label: &#x27;我是测试label2-select&#x27;, formKey: &#x27;year&#x27;, value: &#x27;&#x27;, options: [ &#123; label: 2021, value: 2021 &#125;, &#123; label: 2022, value: 2022 &#125; ], attrs: &#123; placeholder: &#x27;请选择!!&#x27;, &#125; &#125;, ] &#125;&#125; 使用template语法 12345678&lt;Form ref=&quot;generateForm&quot; :model=&#x27;formState&#x27; :rules=&#x27;rules&#x27;&gt; &lt;FormItem :label=&#x27;item.label&#x27; :prop=&quot;item.formKey&quot; v-for=&quot;item in formInits&quot; :key=&#x27;item.formKey&#x27;&gt; &lt;Input v-if=&quot;item.type === &#x27;Input&#x27;&quot; type=&quot;text&quot; v-bind=&#x27;item.attrs&#x27; v-on=&quot;item.listeners&quot;&gt;&lt;/Input&gt; &lt;Select v-else-if=&quot;item.type === &#x27;Select&#x27;&quot; v-bind=&#x27;item.attrs&#x27; v-on=&quot;item.listeners&quot;&gt; &lt;Option v-for=&#x27;opt in item.options&#x27; :key=&#x27;opt.value&#x27; :value=&#x27;opt.value&#x27;&gt;&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt;&lt;/Form&gt; 使用render语法 123456789101112131415161718192021222324252627282930313233343536373839// 这里更加推荐安装JSX-loader 就没有这么痛苦render(createElement)&#123; const returnFormSlot = (&#123; type, options &#125;) =&gt; &#123; switch(type) &#123; case &#x27;Input&#x27;: break; case &#x27;Select&#x27;: return options &amp;&amp; options.map(option =&gt; &#123; return createElement(&#x27;Option&#x27;, &#123; props: &#123; key: option.value, value: option.value, &#125;, &#125;, option.label) &#125;) break; &#125; &#125; return createElement(&#x27;Form&#x27;, &#123; ref: &#x27;generateForm&#x27;, props: &#123; model: this.formState, rules: this.rules &#125; &#125;, this.formInits.map(item =&gt; &#123; return createElement(&#x27;FormItem&#x27;, &#123; props: &#123; label: item.label, prop: item.formKey, &#125; &#125;,[createElement(item.type, &#123; props: item.attrs, on: item.listeners &#125;, returnFormSlot(item) )]) &#125;) )&#125;","categories":[],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"}]}],"categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://hashzzz.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Canvas","slug":"Canvas","permalink":"http://hashzzz.github.io/tags/Canvas/"},{"name":"Fetch","slug":"Fetch","permalink":"http://hashzzz.github.io/tags/Fetch/"},{"name":"Vue3","slug":"Vue3","permalink":"http://hashzzz.github.io/tags/Vue3/"},{"name":"Vue原理","slug":"Vue原理","permalink":"http://hashzzz.github.io/tags/Vue%E5%8E%9F%E7%90%86/"},{"name":"typescript","slug":"typescript","permalink":"http://hashzzz.github.io/tags/typescript/"}]}